In Clang, -Weverything will give you absolutely all warnings
    http://amattn.com/p/better_apps_clang_weverything_or_wall_is_a_lie.html

-g generates debug information

export called on its own (e.g. in nginx Makefile) prints all the current variables in the shell's environment

$(MAKE) (also in the nginx Makefile) generates a recursive call to make using the same binary that was originally used to call make
    https://www.gnu.org/software/make/manual/html_node/MAKE-Variable.html
    Why a recursive call to make here, to begin with?
        Looks like a superset of the release code is found in the target RELEASE. In RELEASE, they're also using Mercurial to commit and tag a release before releasing it

If we remove a variable from a given printf declaration, we get warnings but the code compiles, then we see results like this:
    
    $ ./ex3
    I am 1413429688 years old.

    I am 72 inches tall.

    Why?

        The compiler allocates stack space for the stack frame (for all the local variables), but fails to initialize the data in that memory address to anything if we don't define it, so we're just pointing our variable to some address in memory that has some value
        https://en.wikipedia.org/wiki/Uninitialized_variable#Example_of_the_C_language

    We see the same behavior when we fail to initialize the variable age to any value (int age;), which is even more scary!

If we change the %d to %f in the following printf statement:

    int age = 10;
    printf("I am %d years old.\n", age);
    printf("I am %f years old.\n", age);

    # dylan @ DYLANs-MacBook-Pro in ~/learning/learn_c_the_hard_way on git:master x [21:01:12] C:1
    $ make ex3
    cc -Wall -g    ex3.c   -o ex3
    ex3.c:8:36: warning: format specifies type 'double' but the argument has type 'int' [-Wformat]
        printf("I am %f years old.\n", age);
                     ~~                ^~~
                     %d
    1 warning generated.

    # dylan @ DYLANs-MacBook-Pro in ~/learning/learn_c_the_hard_way on git:master x [21:01:14]
    $ ./ex3
    I am 0.000000 years old.

    That is, we only generate a warning, but the value is 0.0000! Not even an issue with precision - the value is just off!

Valgrind
    Makefile said it was generated by automake, by configure
    I've always run ./configure in a directory, but what does it actually do?
    What's automake?

    Valgrind is most useful when you've compiled your program using the -g flag, i.e. with debugging enabled:

    http://maintainablecode.logdown.com/posts/245425-valgrind-is-not-a-leak-checker

In example 5, things I don't quite understand yet:
    Why the # in front of include?
    char in front of the *argv[] - this is a character array, yeah?
    Why the * in front of argv? This references a pointer, yeah?
    I get return 0, but how does this actually work at the machine level? Why did we choose 0 for successful return values?

Double gives you more precision than float
    Need to read up more about this again

Interestingly, if I try to compile, Valgrind test and run this:

    printf("My whole name is %s %d. %s.\n",
        first_name, initial, last_name);

    it works, where the %d should read %c

    IT PRINTS THE ASCII VALUE FOR the character, in this case 'J' = 74!

This is an interesting example:

    long val = -100000;
    printf("Big number: %lu.\n", val);
    
    prints:

    Big number: 18446744073709451616

    which is 99,999 smaller than the largest possible unsigned long value on a 64-bit computer (my Mac), defined in limits.h as ULONG_MAX
    https://en.wikibooks.org/wiki/C_Programming/C_Reference/limits.h

Why do we see two separate points at which the compiler will flag integer overflow as an issue?
    
    ex7_break_universe_of_defects.c:11:83: warning: overflow in expression; result is 4611686018427387904 with type 'long' [-Winteger-overflow]
    long universe_of_defects = 1L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 500L * 10000000000L;
                                                                                  ^
    ex7_break_universe_of_defects.c:11:90: warning: overflow in expression; result is 0 with type 'long' [-Winteger-overflow]
    long universe_of_defects = 1L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 500L * 10000000000L;
                                                                                         ^
    2 warnings generated.

Signed vs unsigned
    Signed has to represent the space of negative and positive numbers, and needs extra bits to do so. With unsigned numbers, we can steal that bit for more storage, expanding the positive range of numbers we can represent
    If you ever need to represent negative values, you need signed ints

Remember man ascii!

I don't get errors when running Valgrind, or compiling, my example 8 program without a null byte at the end. The program just prints a newline at the end

    Moving the definition for my chararray before the areas array gives me different output, however:

    name="Dylan" and full_name="Dylan J. Sather����ҫ� �)�"

    After ~45 minutes of searching the web, I still couldn't find out why I'm not getting errors. The errors are, however, still reported by the compiler, so in this case I appear to be OK

The size of ints varies depending on the processer architecture, to some degree. On 16-bit machines, the size of ints was the same as the size of a register, or 2 bytes. But since 32-bit machines became so common, the size of the int stayed the same on 64-bit machines (4 bytes)

C stores strings as arrays of bytes, terminated with a null (nul) byte (\0)

    D y l a n \0

argv[0] stores the name of the script we're currently executing, and is generally skipped if iterating through arguments passed to a script. To skip it, execute this for loop:

    // argc is the count of arguments
    for (i = 1; i < argc; i++) {
        printf("argument %d: %s\n", i, argv[i]);
    }

    The operating system passes in the command line arguments, and sets argc to the number of arguments in the argc array

every for loop has three major compontents: 

    for (initializer; test; incrementer) { ...

    Note that the initalizer runs AFTER the code is executed; we then test the condition and if it's satisfied (TRUE), we move on

Our states array is a 2-dimensions character array, the states being elements at the top level, and the characters of states being elements of each sub-array

When we called the program from a Python script, passing in a large number of arguments, we finally hit an error after trying to pass in 100,000 args:

    OSError: [Errno 7] Argument list too long

    But we don't appear to be hitting the OS limit...

    # dylan @ DYLANs-MacBook-Pro in ~/learning/learn_c_the_hard_way on git:master x [11:39:23] C:1
    $ getconf ARG_MAX
    262144

    Read here for more info: http://www.in-ulm.de/~mascheck/various/argmax/

More about for loops - from K&R C
    
    The initializer and incrementer are often assignments of some form
    The test condition is a "relational" expression
    ANY OF THESE THREE PARTS CAN BE OMITTED! The semicolons must remain
        
        for (;;) {
            ...

        This becomes an infinite loop that must return or break at some point

        It's best to keep functions that deal with the execution of the loop in the initialization and incrementation statements

The comma in for loops  - p 62 in K&R

    Used to separate multiple statements. Should be used sparingly!

When I tried to reverse my name string inline, writing back to the same memory that I used to store name, I got the following Valgrind error and a segfault:

    ==1565==  Bad permissions for mapped region at address 0x4006BC
    ==1565==    at 0x400582: main (reverse_my_name.c:15)

The null pointer definitely points nowhere. All other pointers to any real object / function point somewhere. The null pointer points nowhere
    
    http://c-faq.com/null/null1.html

    NULL is defined as a null pointer constant in the C pre-processor
