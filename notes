In Clang, -Weverything will give you absolutely all warnings
    http://amattn.com/p/better_apps_clang_weverything_or_wall_is_a_lie.html

-g generates debug information

export called on its own (e.g. in nginx Makefile) prints all the current variables in the shell's environment

$(MAKE) (also in the nginx Makefile) generates a recursive call to make using the same binary that was originally used to call make
    https://www.gnu.org/software/make/manual/html_node/MAKE-Variable.html
    Why a recursive call to make here, to begin with?
        Looks like a superset of the release code is found in the target RELEASE. In RELEASE, they're also using Mercurial to commit and tag a release before releasing it

If we remove a variable from a given printf declaration, we get warnings but the code compiles, then we see results like this:
    
    $ ./ex3
    I am 1413429688 years old.

    I am 72 inches tall.

    Why?

        The compiler allocates stack space for the stack frame (for all the local variables), but fails to initialize the data in that memory address to anything if we don't define it, so we're just pointing our variable to some address in memory that has some value
        https://en.wikipedia.org/wiki/Uninitialized_variable#Example_of_the_C_language

    We see the same behavior when we fail to initialize the variable age to any value (int age;), which is even more scary!

If we change the %d to %f in the following printf statement:

    int age = 10;
    printf("I am %d years old.\n", age);
    printf("I am %f years old.\n", age);

    # dylan @ DYLANs-MacBook-Pro in ~/learning/learn_c_the_hard_way on git:master x [21:01:12] C:1
    $ make ex3
    cc -Wall -g    ex3.c   -o ex3
    ex3.c:8:36: warning: format specifies type 'double' but the argument has type 'int' [-Wformat]
        printf("I am %f years old.\n", age);
                     ~~                ^~~
                     %d
    1 warning generated.

    # dylan @ DYLANs-MacBook-Pro in ~/learning/learn_c_the_hard_way on git:master x [21:01:14]
    $ ./ex3
    I am 0.000000 years old.

    That is, we only generate a warning, but the value is 0.0000! Not even an issue with precision - the value is just off!

Valgrind
    Makefile said it was generated by automake, by configure
    I've always run ./configure in a directory, but what does it actually do?
    What's automake?

    Valgrind is most useful when you've compiled your program using the -g flag, i.e. with debugging enabled:

    http://maintainablecode.logdown.com/posts/245425-valgrind-is-not-a-leak-checker

In example 5, things I don't quite understand yet:
    Why the # in front of include?
    char in front of the *argv[] - this is a character array, yeah?
    Why the * in front of argv? This references a pointer, yeah?
    I get return 0, but how does this actually work at the machine level? Why did we choose 0 for successful return values?

Double gives you more precision than float
    Need to read up more about this again

Interestingly, if I try to compile, Valgrind test and run this:

    printf("My whole name is %s %d. %s.\n",
        first_name, initial, last_name);

    it works, where the %d should read %c

    IT PRINTS THE ASCII VALUE FOR the character, in this case 'J' = 74!

This is an interesting example:

    long val = -100000;
    printf("Big number: %lu.\n", val);
    
    prints:

    Big number: 18446744073709451616

    which is 99,999 smaller than the largest possible unsigned long value on a 64-bit computer (my Mac), defined in limits.h as ULONG_MAX
    https://en.wikibooks.org/wiki/C_Programming/C_Reference/limits.h

Why do we see two separate points at which the compiler will flag integer overflow as an issue?
    
    ex7_break_universe_of_defects.c:11:83: warning: overflow in expression; result is 4611686018427387904 with type 'long' [-Winteger-overflow]
    long universe_of_defects = 1L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 500L * 10000000000L;
                                                                                  ^
    ex7_break_universe_of_defects.c:11:90: warning: overflow in expression; result is 0 with type 'long' [-Winteger-overflow]
    long universe_of_defects = 1L * 1024L * 1024L * 1024L * 1024L * 1024L * 1024L * 500L * 10000000000L;
                                                                                         ^
    2 warnings generated.

Signed vs unsigned
    Signed has to represent the space of negative and positive numbers, and needs extra bits to do so. With unsigned numbers, we can steal that bit for more storage, expanding the positive range of numbers we can represent
    If you ever need to represent negative values, you need signed ints

Remember man ascii!

I don't get errors when running Valgrind, or compiling, my example 8 program without a null byte at the end. The program just prints a newline at the end

    Moving the definition for my chararray before the areas array gives me different output, however:

    name="Dylan" and full_name="Dylan J. Sather����ҫ� �)�"

    After ~45 minutes of searching the web, I still couldn't find out why I'm not getting errors. The errors are, however, still reported by the compiler, so in this case I appear to be OK

The size of ints varies depending on the processer architecture, to some degree. On 16-bit machines, the size of ints was the same as the size of a register, or 2 bytes. But since 32-bit machines became so common, the size of the int stayed the same on 64-bit machines (4 bytes)

C stores strings as arrays of bytes, terminated with a null (nul) byte (\0)

    D y l a n \0

argv[0] stores the name of the script we're currently executing, and is generally skipped if iterating through arguments passed to a script. To skip it, execute this for loop:

    // argc is the count of arguments
    for (i = 1; i < argc; i++) {
        printf("argument %d: %s\n", i, argv[i]);
    }

    The operating system passes in the command line arguments, and sets argc to the number of arguments in the argc array

every for loop has three major compontents: 

    for (initializer; test; incrementer) { ...

    Note that the initalizer runs AFTER the code is executed; we then test the condition and if it's satisfied (TRUE), we move on

Our states array is a 2-dimensions character array, the states being elements at the top level, and the characters of states being elements of each sub-array

When we called the program from a Python script, passing in a large number of arguments, we finally hit an error after trying to pass in 100,000 args:

    OSError: [Errno 7] Argument list too long

    But we don't appear to be hitting the OS limit...

    # dylan @ DYLANs-MacBook-Pro in ~/learning/learn_c_the_hard_way on git:master x [11:39:23] C:1
    $ getconf ARG_MAX
    262144

    Read here for more info: http://www.in-ulm.de/~mascheck/various/argmax/

More about for loops - from K&R C
    
    The initializer and incrementer are often assignments of some form
    The test condition is a "relational" expression
    ANY OF THESE THREE PARTS CAN BE OMITTED! The semicolons must remain
        
        for (;;) {
            ...

        This becomes an infinite loop that must return or break at some point

        It's best to keep functions that deal with the execution of the loop in the initialization and incrementation statements

The comma in for loops  - p 62 in K&R

    Used to separate multiple statements. Should be used sparingly!

When I tried to reverse my name string inline, writing back to the same memory that I used to store name, I got the following Valgrind error and a segfault:

    ==1565==  Bad permissions for mapped region at address 0x4006BC
    ==1565==    at 0x400582: main (reverse_my_name.c:15)

The null pointer definitely points nowhere. All other pointers to any real object / function point somewhere. The null pointer points nowhere
    
    http://c-faq.com/null/null1.html

    NULL is defined as a null pointer constant in the C pre-processor

C has no built-in boolean type. Instead, an integer that's 0 is false and otherwise it's true. Since computer truth values are simply integers, this makes sense

In general, for loops are more explicit than while loops. Favor for loops, if possible!

Why return 0?
    
    The main function in a C program is typically executed by the environment. It's useful to return status to the environment so that we know whether something worked or failed. Returning a value of 0 indicates to the environment that "all is well", where a non-zero status code would indicate that something went wrong.
    On POSIX systems, a status code of 0 typically indicates success, but that might differ on other systems. In the stdlib (stdlib.h), the macro EXIT_SUCCESS is defined, and for greater portability, you should return EXIT_SUCCESS (https://www.gnu.org/software/libc/manual/html_node/Exit-Status.html)

The stack - http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html
    
    The stack is a special region of computer memory reserved for variables declared in functions, managed by the CPU. The stack is a last in, first out (LIFO) data structure (what does this mean?)
    When a new variable is declared, its value is pushed onto the stack
    When the execution of a function finishes, the memory used by the stack is freed (all variables declared inside the function are "popped" off the stack)
    Luckily, memory on the stack is managed for you! You don't have to manually allocate / free memory
    The CPU also manages this memory very efficiently, so reading from / writing to the stack is very fast
    There's a limit to the size of variables stored in the stack, but not in the heap!

The heap

    The heap is a region of memory not managed by the CPU behind the scenes - it's a free region of memory at your disposal
    When writing to the heap, you must use malloc() or calloc() to allocate a region of memory for use, then call free() to free that region of memory after you're done using it
    Variables written to the heap are accessible from any function, globally
    Since you have to access heap memory yourself, via pointers, it's slower to write to / read from than variables in the stack

Conditionals - if / else statements

    If the test portion evaluates to 0, it is false. Else, it's true. This is similar to the way Python evaluates integers to boolean states
    You MUST put parens around the test condition
    
Switch statement

    In C, the switch statement is technically a "jump table". You can only include expressions that result in integers here, and these integers are used to jump from the top of the switch statement to the portion that matches the specified integer
    Here's how the switch statement works in excrutiating detail:
        The compiler marks the place in the program where the switch statement begins
        The compiler then evaluates the expression in switch(letter) to come up with a number, which in our case is the ASCII code of the letter we're dealing with
        The compiler has also assigned a location to each of the case statements so we know where to jump to when we encounter an ASCII code equal to the value in the case statement
        "It then does the math to figure out where Y+letter is located in the switch-statement, and if it's too far then it adjusts it to Y+default." - What does this mean?
        When you have something like:

            case 'a':
            case 'A':
                ...
                break;

            and say you had 'a' as your input character. The compiler jumps to that location, but then keeps executing, which drops you to the case 'A' block, runs your code, and only then breaks. This is why this works to capture both lower and uppercase characters

    Remember to always include a 'default' branch to catch inputs you don't expect
    Always start writing the case: and break; statements first so you enumerate your conditions, before writing any other code! 
        This is probably good practice for other loops and conditional statements, too
    Try to use if statements if you can. They're simpler.

We saw an example of a non-zero exit code in the case in which we don't provide enough arguments to the program in example 13. Here's how that looks in our environment:

    vagrant@precise64:~/tree/learn_c_the_hard_way$ ./ex13 A
    0: 'A'
    vagrant@precise64:~/tree/learn_c_the_hard_way$ echo $?
    0
    vagrant@precise64:~/tree/learn_c_the_hard_way$ ./ex13
    ERROR: You need one argument.
    vagrant@precise64:~/tree/learn_c_the_hard_way$ echo $?
    1

Function declarations

    Forward declaration - if you're using a function before you declare it, you'll need to add a declaration at the top of the program. But why?
        When you fail to include these declarations at the top of the file, you'll get some errors from the compiler that look something like this:

            vagrant@precise64:~/tree/learn_c_the_hard_way$ make ex14
            clang -Wall -g    ex14.c   -o ex14
            ex14.c:13:9: warning: implicit declaration of function 'print_letters' is invalid in C99 [-Wimplicit-function-declaration]
                    print_letters(argv[i]);
                    ^
            ex14.c:17:6: error: conflicting types for 'print_letters'
            void print_letters(char arg[])
                 ^
            ex14.c:13:9: note: previous implicit declaration is here
                    print_letters(argv[i]);
                    ^
            ex14.c:25:13: warning: implicit declaration of function 'can_print_it' is invalid in C99 [-Wimplicit-function-declaration]
                    if (can_print_it(ch)) {
                        ^
            ex14.c:33:5: error: conflicting types for 'can_print_it'
            int can_print_it(char ch)
                ^
            ex14.c:25:13: note: previous implicit declaration is here
                    if (can_print_it(ch)) {

Example 15 - Pointers    

    int * -> pointer to integer
    We've seen char * before, a pointer to a character. A string is simply an array of characters
        cur_age points to a single integer, but ages holds an array of integers. Similarly, a pointer to a _single_ character can be the beginning of a string
    But next, we define a pointer to a pointer to a char, char **cur_name
        A pointer to a char points to a single character, or the start of a chararray (array of characters, or a string)
        Since we have an array of strings, we need to keep two indices - one to the current character we're processing, and another to the string we're processing in the array of strings

    *(cur_name+i) -> the value of (pointer cur_name + i)
    *(cur_name+i) is equivalent to writing name[i]

    (cur_age - ages) < count
        This compares the distance between cur_age and ages to count
        Does this work because as we move our pointer (cur_age), pointer arithmetic returns integer values for the distance between cur_age and ages (effectively the start of the array, at 0)?

    Incrementing a pointer that points to an element of an array points that pointer to the next element of the array

    An array of integers in C is a set of memory allocated to the space needed to store these integers
    If you dereference the value of ages, the compiler will replace it with the address pointing to the first integer
    In our program, ages is an address inside the entire computer, where the indices like i that we've been using before reference addresses within a single array like ages

    "C thinks your whole computer is one massive array of bytes"

    So if ages just points to the address of the start of an array of integers, and you want to move that address sequentially to find your target integer, is there another way you can always
    keep track of the "current index" in a value without incrementing another variable? Yes, A POINTER

    Pointer are variables that point to a specific location in the memory of your computer
    You need to specify the type of a pointer to make sure you get the right size of data with it (and move by N bytes as you traverse arrays, for instance, where N is the number of bytes used
    to store values of that type

    Traditionally, for the uses we've seen so far, we want to work with arrays. But when we need direct access to computer memory, we need pointers

    You can use both indices and pointers to reference addresses in memory - these are virtually interchangeable for what we've been doing so far

    Pointers in practice - 4 major things we need pointers for
        Ask the OS for a chunk of memory and use a pointer to work with it. We can do this with strings, and structs
        Passing large blocks of memory to functions AS POINTERS so you don't have to pass the whole struct to them
            What does this mean?
        Taking the address of a function so you can use it as a dynamic callback
            What does this mean?
        Other, complex handling of memory, e.g. reading in files / scanning bytes of data from the network

    You see people using pointers where they should be using arrays a lot, because compilers used to be poor at optimizing array code. Now, that's not the case. You should use a pointer only 
    in the cases above, and use an array every other time. It's more readable and easier to understand.
